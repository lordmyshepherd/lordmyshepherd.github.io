---
title: "면접준비(기술)"
date: "2020-01-18T22:40:32.169Z"
template: "post"
draft: false
slug: "/posts/면접준비(기술)"
category: ""
tags:
description: "#TDD, #Bcrypt, #JWT, #자료구조, #RESTful API, #서버 부하 문제(백앤드 개발자 역량)"
socialImage: "/media/42-line-bible.jpg"
---
*The Lord is my shepherd, I lack nothing. PSLAM 23:1*

### 질문 내용
1. TDD 관련 질문
2. 자료 구조 관련 질문
3. 파이썬 관련 질문
4. RESTful API 관련 질문
5. 백앤드 개발자 역량(서버 부하 문제) 관련 질문


### 1. TDD 관련 질문
**TDD란 무엇인가?**  
Test Driven Development의 약로 테스트를 기반으로 코드를 작성하며 개발을 이끌어 나간다는 의미입니다.
처음에 실패할 수 밖에 없는 test 코드를 작성하고 이를 통과하도록 코드를 작성하는 것이 TDD의 개념입니다.

**TDD를 왜 적용해야할까?**  
TDD는 '테스트 통과 여부를 통한 피드백'과 '협력'을 증진시켜주기 때문에 높아진 SW 개발의 불확실성시대에 좋은 결과가 나올 수 있는 확률을 높여줍니다.

**장점과 단점**  
1. 단점  
   처음부터 2개의 코드를 짜야하고, 중간중간 테스트를 하면서 고쳐나가야하기 때문에 개발 속도가 느려집니다.
2. 장점
   + 테스트 코드에는 개발자의 의도가 담겨져 있기 때문에 협력할 때 도움이됩니다.
   + 버그를 줄일 수 있습니다.
   + 코드의 가독성이 좋아집니다.
   + 유지보수 비용이 낮아집니다.

**TDD를 잘 활용하는 방법**  
나 스스로 ‘어떻게 해야 피드백을 더 자주 받을까’, ‘어떻게 해야 내가 하는 작업에 대해 협력이 잘 일어나게 할까’를 고민하면서 계속해서 내가 일하는 방식을 업그레이드 해야한다.

### 2. 자료구조 관련 질문
**Array와 Set의 차이가 무엇인가?**  
 
1. Array  
   + Array의 특징  
   Array는 데이터가 실제 메모리 상에서 순차적으로 저장되기 때문에 **"순서(order)"가 있습니다.** 이렇게 순서가 있다보니 indexing을 할 수 있습니다.
   + 언제 사용하면 좋을까?  
   (1)순차열적인 데이터를 저장항때  
   (2)어떤 특정 요소를 index로 빠르게 읽어야 할때  
   (3)데이터의 사이즈가 급변하게 자주 변하지 않을때  
   (4)요소를 자주 삭제해야 하지 않을때(왜? --> Array Resizing)  
2. Set  
   + Set의 특징  
   set은 array처럼 순열 자료구조(collection)지만, 순서라는 개념이 존재하지 않고, 중복된 값이 허용이 안되는 자료구조 입니다.   
   ```python
   [참고] 순열 : 요소를 일렬로 배열하는 경우를 말함.
   ```
   + 왜 순서가 없을까?  
   set은 실제로 요소돌을 순차적으로 저장하지 않습니다. 
   저장할 요소의 값의 hash 값을 구하고 --> 해쉬값에 해당하는 물리적인 공간(bucket)에 값을 저장하기 때문에 **순서가 없고 indexing**도 없습니다.

   + 언제 사용하면 좋을끼?   
   (1)순서가 상관 없으면서,중복된 값을 골라내야 할때 (예: 주민등록번호, 전화번호 등등..)  
   (2)빠르게 특정 값을 포함하고 있는지를 확인(look up)해야 할때 (Set의 총 길이와 상관 없이 단순히 해쉬값을 계산하고 해당 bucket을 확인하면 됨으로 O(1)이다. Array로 찾을 경우에 for문을 두번 돌려야하기 때문에 O(N^2)으로 굉장히 느리다.)
   ```python
   [참고] 값을 찾는 방법 : 해싱된 값을 set의 size로 나눈 나머지로 찾아 들어간다.
   [참고] 값을 치환해서 저장하는 이유(중복 입력시) : Coord(1,0) == Coord(1,0) 을 생각해보자. 같은가? 다른가?
   숫자 1이라는 값이 내가 생각하기에는 같다고 생각 하지만 파이썬도 그렇게 생각하는가?
   1도 Number라는 class의 객체이다.
   모든 class는 object라는 상위 class를 상속받는다.
   여기에는 equal() 이라는 함수가 있는데, 이녀석이 값이 같은지 Coord(1,0) == Coord(1,0) 를 비교할때는 메모리주소를 비교하기 때문에 false가 나온다. Coord라는 class에 def __eq__을 추가해주면 된기는 하지만.. 
   결국에 새로 넣는 값을 일단 치환하고 본다.
   ```

**Array와 Linkedlist의 장점과 단점**  

1. **데이터 접근 속도(배열 >>> 링크드리스트)**  
배열은 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근이 가능하기 때문에 데이터 접근 속도가 매우 빠르지만, 연결리스트는 현재 위치의 이전 및 다음 위치를 기억하고 있습니다.  
그럼으로 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하기 때문에 데이터 접근 속도가 떨어집니다.

2. **데이터 삽입/삭제(링크드리스트 >>> 배열)**   
배열은 데이터의 삽입/삭제에 취약합니다. 배열 특성상 데이터 삽입/삭제가 이루어지면 실제 메모리상에서 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문입니다.  
연결리스트에서 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 훨씬 쉽습니다.

3. **메모리 효율(배열 >>> 링크드리스트)**  
동일한 양의 데이터를 저장해도 일반적으로 연결 리스트가 배열보다 더 많은 메모리를 차지하게 됩니다.  (배열은 단순 데이터 저장인데 비해 연결 리스트는 각 노드마다 객체를 생성해야 함으로)

4. **언제 linkedlist를 사용하는 것이 좋을까?**  
데이터 양이 많지만 데이터의 삽입/삭제가 거의 없고,  
데이터 접근이 빈번하게 이루어질 경우는 배열이 유리하고,   
데이터 양이 그렇게 많지 않고,   
데이터의 삽입/삭제가 빈번하게 이루어질 경우에는 연결리스트를 사용하는것이 더 유리합니다.

**Tree 구조는 언제 사용하나요?**  
1. 효율적 검색  
Tree 구조는 데이터의 저장의 의미 보다는 저장된 데이터를 더 효과적으로 탐색 하기 위해서 사용됩니다.
이진 트리는 검색을 효율적으로 할 수 있습니다. 원하는 값을 찾을 때까지, 현재 node의 값이 원하는 값보다 크면 왼쪽으로, 작으면 오른쪽 으로 움직이면 됩니다.  
그럼으로 일반 list는 검색이 O(N)인데에 비해 이진 트리는 O(log N) 이므로 리스트 보다 검색이 훨씬 효율 적입니다.

### 3. 파이썬 관련 질문

1. 데코레이터(decorator) 관련 질문
   + decorator란 무엇인가?  
   소스 코드를 바꾸지 않고, 사용하고 있는 함수를 수정하고 싶을 때가 있다. 데코레이터는 하나의 함수를 취해서 또 다른 함수를 반환하는 함수입니다.
   + decorator 동작 원리


2. 구현했다고 이력서에 작성한 로직들을 어떻게 구성했는지?  
   + 인증(회원가입 로그인) 기능 구현 로직  
   **회원가입** : bcrypt 알고리즘을 이용해서 비밀번호를 암호화하여 저장함.  
   **로그인** : brcrpy 모듈의 checkpw 함수를 사용해서 사용자의 비밀번호를 동일하게 암호화해서 이미 암호화되어 있는 비밀번호와 동일한지를 확인 후, PyJWT 모듈을 이용해서 JWT를 생성하여 반환함. 또한 tyr, except 구문을 이용해서 로그인시 발생할 수 있는 에러를 핸들링함.  

   + 인가(decorator를 이용한 로그인 권한이 필요한 엔드포인트에 권한 부여) 기능 구현
   request headers에 JWT token이 존재하는 경우에 해당 함수가 실행될 수 있도록 하는 로직

3. Bcrypt 관련 질문
   + 작동원리  
   단방향 해쉬 함수(one-way hash function)가 사용된다. 단방향 해시 함수는 원본 데이터를 변환하여 암호화된 메시지인 다이제스트(diget)를 생성한다. 원본 메세지를 알면 암호화된 메시지를 구하기는 쉽지만 암호화된 메시지로는 원본 메시지를 구할 수 없어서 단방향성 이라고 한다.
   + 단방향 해쉬 함수의 취약점
      1. Rainbow table attack : 미리 해쉬값들을 전부 계산해 놓은 테이블을 Rainbow table이라고 한다. 
      매우 빠른 속도로 rainbow 테이블의 값과 다이제스트를 비교하면 패스워드가 충분히 길거나 복잡하지 않은 경우에는 그리 긴 시간이 걸리지 않는다.
   + 보완 방법
      1. Salting : 실제 비밀번호 이외에 추가적으로 랜덤 데이터를 더해서 해시값을 계산하는 방법
      2. Key Stretching : 단방향 해쉬값을 계산 한 후 그 해쉬값을 또 또 해쉬하고, 또 이를 반복하는 것을 말한다.

4. JWT(JSON Web Tokens) 관련 질문
   + **access token이란 무엇인가?**  
   HTTP 통신은 stateless 성격 때문에, 각각의 HTTP 통신은 독립적이며 이전에 어떠한 통신들이 실행됐는지 알지 못한다. 이러한 HTTP의 성질 때문에 
   생기는 이슈 중 하나가 바로 인증 절차다.  
   핸재의 HTTP 통신에서 이전에 통신에서 이미 인증이 진행됐는지 알지 못하기 때문이다. 그러므로 통신을 할 때는 해당 HTTP 요청을 처리하기 위해서 필요한 모든 데이터(로그인 정보 등)를 첨부해서 요청을 보내야 한다.  
   access token은 바로 로그인 정보를 담고있는 데이터이다.

   + **JWT란 무엇인가?**  
   access token을 생성하는 방법 중 가장 널리 사용되는 기술 중 하나가 바로 JWT(JSON Web Tokens)이다. JWT는 말 그대로 json 데이터를 token으로 변환하는 방식이다.

   + **왜 굳이 json 데이터를 토큰화 시켜서 사용하는가?**  
   단순 JSON 데이터를 사용하면 해킹 가능성의 문제가 생긴다. 누구나 JSON 데이터를 HTTP 요청에 첨부해서 전송할 수 있으므로 실제 해당 사용자가 아님에도 해당 사용자라고 인식될 수 있다. 
   그렇기 때문에 토큰은 누군가가 해킹 목적으로 가짜 JWT를 전송한다고 해도 API 서버에서 자신이 생성한 JWT인지 아닌지 확인하는 기능도 제공한다.

   + **JWT은 어떻게 만들어지는가?**  
   파이썬에서는 PyJWT 라이브러리를 사용해서 구현할 수 있다. JWT를 생성하고 복화하도 할 수 있게 해주는 라이브러이다.  
      + JWT의 구조  
      header, payload, signature 세 부분으로 구성되어 있다.
      ```python
      #JWT 일반적인 형태
      xxxxxx.yyyyyyy.zzzzzz
      ```
      (1) **header(xxxxxx)**  
      ```python
      #헤더는 두 부분으로 되어 있으며, 토큰 타입과 사용되는 해시알고리즘을 지정한다.
      {
            "alg": "HS256",
            "typ": "JWT"
      }
      #header를 Base64URL 방식으로 코드화해서 JWT의 첫 부분을 구성한다.  
      ```
      (2) **payload(yyyyy)**    
      ```python
      #payload는 JWT를 통해 실제로 서버 간에 전송하고자 하는 데이터 부분이다.
      {
            "user_id": "2",
            "exp": 123123124
      }
      #payload도 Base64URL 코드화(encoding)되어서 JWT의 두 번째 부분을 구성한다.
      #코드화는 암호화가 아니다. 누구나 복원이 가능하다. 그러므로 민감한 정보는 넣지 않는 것이 좋다. 예를 들어, 실제 사용자의 개인정보 등은 절대로 넣지 않도록 한다.
      ```
      (3) **signature(zzzzzz)**  
      ```python
      #JWT가 원본 그대로라는 것을 확인할 때 사용되는 부분이다.
      #signature는 Base64URL 방식으로 코드화된 (1)header와 (2)payload, 그리고 JWT secret key를 헤더에 저장된 암호 알고르짐으로 암호화되어서 마지막 부분을 구성한다. (복호화가 가능한 암호) 
      #나중에 JWT의 signature 부분을 복호화하여, 서버에서 생성한 JWT가 맞는지 확인한다.
      #로그인 시 JWT를 반환해주는 엔드포인트 (PyJWT를 활용해서 구현)
      class SignInView(View) :
      def post(self, request) :
            credential = json.loads(request.body)

            try :
                  user = Users.objects.get(email=credential["email"])
                  if bcrypt.checkpw(credential["password"].encode("utf-8"), user.password.encode("utf-8")) :

                  #토큰으로 만들려고하는 json data
                  payload             = {"user_id" : user.id}

                  #코드화된 header, payload를 암호화하기 위해 필요한 재료
                  encryption_secret   = SECRET_KEY

                  #header에 들어갈 암호화에 사용될 알고리증 정보
                  algorithm           = "HS256"

                  #PyJWT 알고리즘을 
                  encoded             = jwt.encode(payload, encryption_secret, algorithm=algorithm)
                  return JsonResponse({"access_token":encoded.decode("utf-8")}, status=200)
                  else :
                  return JsonResponse({"message":"INVALID_PASSWORD"}, status=401)
            except Users.DoesNotExist:
                  return JsonResponse({"message":"INVALID_EMAIL"}, status=401

                  # JWT의 payload 부분에 들어갈 JSON 데이터
                  payload = {"user_id" : user.id} 
                  # JWT의 signatue 부분을 암호화할 때 사용할 비밀 키 지정
                  encryption_secret = SECRET_KEY
                  #  
      ```
   + **JWT의 만료 기간을 어떻게 정하실 건가요?**  
   "Facebook 같이 장시간 로그인이 필요한 경우는 기간을 오래하는게 맞는것 같다."라고 대답한다면.... 다음과 같은 질문이 들어올 것이다.
   토큰을 오랜시간 동안 사용하면 해킹당할 위험이 높이질 수 있지 않나요?
   제대로된 답은 "기간을 짧게 정하고 토큰을 재발행 해주는 방법을 사용해야 된다."