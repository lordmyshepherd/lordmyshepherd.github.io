{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/면접준비(일반)","result":{"data":{"markdownRemark":{"id":"cf91ab05-ef32-5f91-9596-5fd56b8697e6","html":"<p><em>The Lord is my shepherd, I lack nothing. PSLAM 23:1</em></p>\n<h3 id=\"1-회사-지원-동기\"><a href=\"#1-%ED%9A%8C%EC%82%AC-%EC%A7%80%EC%9B%90-%EB%8F%99%EA%B8%B0\" aria-label=\"1 회사 지원 동기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 회사 지원 동기</h3>\n<p><strong>네오사피에엔스(주)</strong><br>\n서비스 : typecast (텍스트에 성우의 목소리를 캐스팅하는 인공지능 성우 서비스)</p>\n<p><strong>TDD를 왜 적용해야할까?</strong><br>\nTDD는 ‘테스트 통과 여부를 통한 피드백’과 ‘협력’을 증진시켜주기 때문에 높아진 SW 개발의 불확실성시대에 좋은 결과가 나올 수 있는 확률을 높여줍니다.</p>\n<p><strong>장점과 단점</strong>  </p>\n<ol>\n<li>단점<br>\n처음부터 2개의 코드를 짜야하고, 중간중간 테스트를 하면서 고쳐나가야하기 때문에 개발 속도가 느려집니다.</li>\n<li>\n<p>장점</p>\n<ul>\n<li>테스트 코드에는 개발자의 의도가 담겨져 있기 때문에 협력할 때 도움이됩니다.</li>\n<li>버그를 줄일 수 있습니다.</li>\n<li>코드의 가독성이 좋아집니다.</li>\n<li>유지보수 비용이 낮아집니다.</li>\n</ul>\n</li>\n</ol>\n<p><strong>TDD를 잘 활용하는 방법</strong><br>\n나 스스로 ‘어떻게 해야 피드백을 더 자주 받을까’, ‘어떻게 해야 내가 하는 작업에 대해 협력이 잘 일어나게 할까’를 고민하면서 계속해서 내가 일하는 방식을 업그레이드 해야한다.</p>\n<h3 id=\"2-자료구조-관련-질문\"><a href=\"#2-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8\" aria-label=\"2 자료구조 관련 질문 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 자료구조 관련 질문</h3>\n<p><strong>Array와 Set의 차이가 무엇인가?</strong>  </p>\n<ol>\n<li>\n<p>Array  </p>\n<ul>\n<li>Array의 특징<br>\nArray는 데이터가 실제 메모리 상에서 순차적으로 저장되기 때문에 <strong>“순서(order)“가 있습니다.</strong> 이렇게 순서가 있다보니 indexing을 할 수 있습니다.</li>\n<li>언제 사용하면 좋을까?<br>\n(1)순차열적인 데이터를 저장항때<br>\n(2)어떤 특정 요소를 index로 빠르게 읽어야 할때<br>\n(3)데이터의 사이즈가 급변하게 자주 변하지 않을때<br>\n(4)요소를 자주 삭제해야 하지 않을때(왜? —> Array Resizing)  </li>\n</ul>\n</li>\n<li>\n<p>Set  </p>\n<ul>\n<li>\n<p>Set의 특징<br>\nset은 array처럼 순열 자료구조(collection)지만, 순서라는 개념이 존재하지 않고, 중복된 값이 허용이 안되는 자료구조 입니다.   </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token punctuation\">[</span>참고<span class=\"token punctuation\">]</span> 순열 <span class=\"token punctuation\">:</span> 요소를 일렬로 배열하는 경우를 말함<span class=\"token punctuation\">.</span></code></pre></div>\n</li>\n<li>왜 순서가 없을까?<br>\nset은 실제로 요소돌을 순차적으로 저장하지 않습니다.\n저장할 요소의 값의 hash 값을 구하고 —> 해쉬값에 해당하는 물리적인 공간(bucket)에 값을 저장하기 때문에 <strong>순서가 없고 indexing</strong>도 없습니다.</li>\n<li>\n<p>언제 사용하면 좋을끼?<br>\n(1)순서가 상관 없으면서,중복된 값을 골라내야 할때 (예: 주민등록번호, 전화번호 등등..)<br>\n(2)빠르게 특정 값을 포함하고 있는지를 확인(look up)해야 할때 (Set의 총 길이와 상관 없이 단순히 해쉬값을 계산하고 해당 bucket을 확인하면 됨으로 O(1)이다. Array로 찾을 경우에 for문을 두번 돌려야하기 때문에 O(N^2)으로 굉장히 느리다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token punctuation\">[</span>참고<span class=\"token punctuation\">]</span> 값을 찾는 방법 <span class=\"token punctuation\">:</span> 해싱된 값을 <span class=\"token builtin\">set</span>의 size로 나눈 나머지로 찾아 들어간다<span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">[</span>참고<span class=\"token punctuation\">]</span> 값을 치환해서 저장하는 이유<span class=\"token punctuation\">(</span>중복 입력시<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> Coord<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> Coord<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> 을 생각해보자<span class=\"token punctuation\">.</span> 같은가? 다른가?\n숫자 <span class=\"token number\">1</span>이라는 값이 내가 생각하기에는 같다고 생각 하지만 파이썬도 그렇게 생각하는가?\n<span class=\"token number\">1</span>도 Number라는 <span class=\"token keyword\">class</span>의 객체이다<span class=\"token punctuation\">.</span>\n모든 <span class=\"token keyword\">class</span>는 <span class=\"token builtin\">object</span>라는 상위 <span class=\"token keyword\">class</span>를 상속받는다<span class=\"token punctuation\">.</span>\n여기에는 equal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 이라는 함수가 있는데<span class=\"token punctuation\">,</span> 이녀석이 값이 같은지 Coord<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> Coord<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> 를 비교할때는 메모리주소를 비교하기 때문에 false가 나온다<span class=\"token punctuation\">.</span> Coord라는 <span class=\"token keyword\">class</span>에 <span class=\"token keyword\">def</span> __eq__을 추가해주면 된기는 하지만<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n결국에 새로 넣는 값을 일단 치환하고 본다<span class=\"token punctuation\">.</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Array와 Linkedlist의 장점과 단점</strong>  </p>\n<ol>\n<li><strong>데이터 접근 속도(배열 >>> 링크드리스트)</strong><br>\n배열은 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근이 가능하기 때문에 데이터 접근 속도가 매우 빠르지만, 연결리스트는 현재 위치의 이전 및 다음 위치를 기억하고 있습니다.<br>\n그럼으로 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하기 때문에 데이터 접근 속도가 떨어집니다.</li>\n<li><strong>데이터 삽입/삭제(링크드리스트 >>> 배열)</strong><br>\n배열은 데이터의 삽입/삭제에 취약합니다. 배열 특성상 데이터 삽입/삭제가 이루어지면 실제 메모리상에서 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문입니다.<br>\n연결리스트에서 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 훨씬 쉽습니다.</li>\n<li><strong>메모리 효율(배열 >>> 링크드리스트)</strong><br>\n동일한 양의 데이터를 저장해도 일반적으로 연결 리스트가 배열보다 더 많은 메모리를 차지하게 됩니다.  (배열은 단순 데이터 저장인데 비해 연결 리스트는 각 노드마다 객체를 생성해야 함으로)</li>\n<li><strong>언제 사용하는 것이 좋을까?</strong><br>\n데이터 양이 많지만 데이터의 삽입/삭제가 거의 없고, 데이터 접근이 빈번하게 이루어질 경우는 배열이 유리하고, 데이터 양이 그렇게 많지 않고, 데이터의 삽입/삭제가 빈번하게 이루어질 경우에는 연결리스트를 사용하는것이 더 유리합니다.</li>\n</ol>\n<p><strong>Tree 구조는 언제 사용하나요?</strong>  </p>\n<ol>\n<li>효율적 검색<br>\nTree 구조는 데이터의 저장의 의미 보다는 저장된 데이터를 더 효과적으로 탐색 하기 위해서 사용됩니다.\n이진 트리는 검색을 효율적으로 할 수 있습니다. 원하는 값을 찾을 때까지, 현재 node의 값이 원하는 값보다 크면 왼쪽으로, 작으면 오른쪽 으로 움직이면 됩니다.<br>\n그럼으로 일반 list는 검색이 O(N)인데에 비해 이진 트리는 O(log N) 이므로 리스트 보다 검색이 훨씬 효율 적입니다.</li>\n</ol>\n<h3 id=\"3-파이썬-관련-질문\"><a href=\"#3-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8\" aria-label=\"3 파이썬 관련 질문 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 파이썬 관련 질문</h3>\n<ol>\n<li>데코레이터 설명에 대해 설명하시오.<br>\n소스 코드를 바꾸지 않고, 사용하고 있는 함수를 수정하고 싶을 때가 있다. 데코레이터는 하나의 함수를 취해서 또 다른 함수를 반환하는 함수입니다.</li>\n<li>\n<p>구현했다고 이력서에 작성한 로직들을 어떻게 구성했는지?  </p>\n<ul>\n<li>인증(회원가입 로그인) 기능 구현 로직<br>\n<strong>회원가입</strong> : bcrypt 알고리즘을 이용해서 비밀번호를 암호화하여 저장함.<br>\n<strong>로그인</strong> : brcrpy 모듈의 checkpw 함수를 사용해서 사용자의 비밀번호를 동일하게 암호화해서 이미 암호화되어 있는 비밀번호와 동일한지를 확인 후, PyJWT 모듈을 이용해서 JWT를 생성하여 반환함. 또한 tyr, except 구문을 이용해서 로그인시 발생할 수 있는 에러를 핸들링함.  </li>\n<li>인가(decorator를 이용한 로그인 권한이 필요한 엔드포인트에 권한 부여) 기능 구현\nrequest headers에 JWT token이 존재하는 경우에 해당 함수가 실행될 수 있도록 하는 로직</li>\n</ul>\n</li>\n<li>\n<p>Bcrypt</p>\n<ul>\n<li>작동원리<br>\n단방향 해쉬 함수(one-way hash function)가 사용된다. 단방향 해시 함수는 원본 데이터를 변환하여 암호화된 메시지인 다이제스트(diget)를 생성한다. 원본 메세지를 알면 암호화된 메시지를 구하기는 쉽지만 암호화된 메시지로는 원본 메시지를 구할 수 없어서 단방향성 이라고 한다.</li>\n<li>\n<p>단방향 해쉬 함수의 취약점</p>\n<ol>\n<li>Rainbow table attack : 미리 해쉬값들을 전부 계산해 놓은 테이블을 Rainbow table이라고 한다.\n매우 빠른 속도로 rainbow 테이블의 값과 다이제스트를 비교하면 패스워드가 충분히 길거나 복잡하지 않은 경우에는 그리 긴 시간이 걸리지 않는다.</li>\n</ol>\n</li>\n<li>\n<p>보완 방법</p>\n<ol>\n<li>Salting : 실제 비밀번호 이외에 추가적으로 랜덤 데이터를 더해서 해시값을 계산하는 방법</li>\n<li>Key Stretching : 단방향 해쉬값을 계산 한 후 그 해쉬값을 또 또 해쉬하고, 또 이를 반복하는 것을 말한다.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>JWT(JSON Web Tokens) 관련 질문</p>\n<ul>\n<li>access token이란 무엇인가?\nHTTP 통신은 stateless 성격 때문에, 각각의 HTTP 통신은 독립적이며 이전에 어떠한 통신들이 실행됐는지 알지 못한다. 이러한 HTTP의 성질 때문에\n생기는 이슈 중 하나가 바로 인증 절차다.</li>\n</ul>\n<p>핸재의 HTTP 통신에서 이전에 통신에서 이미 인증이 진행됐는지 알지 못하기 때문이다. 그러므로 통신을 할 때는 해당 HTTP 요청을 처리하기 위해서 필요한 모든 데이터(로그인 정보 등)를 첨부해서 요청을 보내야 한다.\naccess token은 바로 로그인 정보를 담고있는 데이터이다.</p>\n<p>이라고 하는 암호화된 유저 정보를 담고 있는 토큰을 생성하는 기술 중 하나가 바로 JWT입니다.</p>\n<ul>\n<li>JWT는 말 그대로 유저 정보를 담은 JSON 데이터를 암호화해서 클라이언트와 서버간에 주고 받는 것이다.</li>\n</ul>\n</li>\n</ol>","fields":{"slug":"/posts/면접준비(일반)","tagSlugs":null},"frontmatter":{"date":"2020-01-09T22:40:32.169Z","description":"#지원동기, #커뮤니케이션","tags":null,"title":"면접준비(일반)","socialImage":"/media/42-line-bible.jpg"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/면접준비(일반)"}}}